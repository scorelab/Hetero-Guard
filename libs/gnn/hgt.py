import numpy as np

import torch
import torch.nn.functional as F
from copy import deepcopy
from sklearn.metrics import accuracy_score, f1_score, roc_auc_score

import math
from typing import Dict, List, Optional, Union

from torch import Tensor
from torch.nn import Parameter
from torch_sparse import SparseTensor

from torch_geometric.nn.conv import MessagePassing
from torch_geometric.nn.dense import Linear
from torch_geometric.nn.inits import glorot, ones, reset
from torch_geometric.typing import EdgeType, Metadata, NodeType, OptTensor
from torch_geometric.utils import softmax


def group(xs: List[Tensor], aggr: Optional[str]) -> Optional[Tensor]:
    if len(xs) == 0:
        return None
    elif aggr is None:
        return torch.stack(xs, dim=1)
    elif len(xs) == 1:
        return xs[0]
    else:
        out = torch.stack(xs, dim=0)
        out = getattr(torch, aggr)(out, dim=0)
        out = out[0] if isinstance(out, tuple) else out
        return out


class HGTConv(MessagePassing):
    r"""The Heterogeneous Graph Transformer (HGT) operator from the
    `"Heterogeneous Graph Transformer" <https://arxiv.org/abs/2003.01332>`_
    paper.

    .. note::

        For an example of using HGT, see `examples/hetero/hgt_dblp.py
        <https://github.com/pyg-team/pytorch_geometric/blob/master/examples/
        hetero/hgt_dblp.py>`_.

    Args:
        in_channels (int or Dict[str, int]): Size of each input sample of every
            node type, or :obj:`-1` to derive the size from the first input(s)
            to the forward method.
        out_channels (int): Size of each output sample.
        metadata (Tuple[List[str], List[Tuple[str, str, str]]]): The metadata
            of the heterogeneous graph, *i.e.* its node and edge types given
            by a list of strings and a list of string triplets, respectively.
            See :meth:`torch_geometric.data.HeteroData.metadata` for more
            information.
        heads (int, optional): Number of multi-head-attentions.
            (default: :obj:`1`)
        group (string, optional): The aggregation scheme to use for grouping
            node embeddings generated by different relations.
            (:obj:`"sum"`, :obj:`"mean"`, :obj:`"min"`, :obj:`"max"`).
            (default: :obj:`"sum"`)
        **kwargs (optional): Additional arguments of
            :class:`torch_geometric.nn.conv.MessagePassing`.
    """
    def __init__(
        self,
        in_channels: Union[int, Dict[str, int]],
        out_channels: int,
        metadata: Metadata,
        heads: int = 1,
        group: str = "sum",
        **kwargs,
    ):
        super().__init__(aggr='add', node_dim=0, **kwargs)

        if not isinstance(in_channels, dict):
            in_channels = {node_type: in_channels for node_type in metadata[0]}

        self.in_channels = in_channels
        self.out_channels = out_channels
        self.heads = heads
        self.group = group

        self.k_lin = torch.nn.ModuleDict()
        self.q_lin = torch.nn.ModuleDict()
        self.v_lin = torch.nn.ModuleDict()
        self.a_lin = torch.nn.ModuleDict()
        self.skip = torch.nn.ParameterDict()
        for node_type, in_channels in self.in_channels.items():
            self.k_lin[node_type] = Linear(in_channels, out_channels)
            self.q_lin[node_type] = Linear(in_channels, out_channels)
            self.v_lin[node_type] = Linear(in_channels, out_channels)
            self.a_lin[node_type] = Linear(out_channels, out_channels)
            self.skip[node_type] = Parameter(torch.Tensor(1))

        self.a_rel = torch.nn.ParameterDict()
        self.m_rel = torch.nn.ParameterDict()
        self.p_rel = torch.nn.ParameterDict()
        dim = out_channels // heads
        for edge_type in metadata[1]:
            edge_type = '__'.join(edge_type)
            self.a_rel[edge_type] = Parameter(torch.Tensor(heads, dim, dim))
            self.m_rel[edge_type] = Parameter(torch.Tensor(heads, dim, dim))
            self.p_rel[edge_type] = Parameter(torch.Tensor(heads))

        self.reset_parameters()

    def reset_parameters(self):
        reset(self.k_lin)
        reset(self.q_lin)
        reset(self.v_lin)
        reset(self.a_lin)
        ones(self.skip)
        ones(self.p_rel)
        glorot(self.a_rel)
        glorot(self.m_rel)


    def forward(
        self,
        x_dict: Dict[NodeType, Tensor],
        edge_index_dict: Union[Dict[EdgeType, Tensor],
                               Dict[EdgeType, SparseTensor]],  # Support both.,
        edge_weight_dict: OptTensor
    ) -> Dict[NodeType, Optional[Tensor]]:
        r"""
        Args:
            x_dict (Dict[str, Tensor]): A dictionary holding input node
                features  for each individual node type.
            edge_index_dict (Dict[str, Union[Tensor, SparseTensor]]): A
                dictionary holding graph connectivity information for each
                individual edge type, either as a :obj:`torch.LongTensor` of
                shape :obj:`[2, num_edges]` or a
                :obj:`torch_sparse.SparseTensor`.

        :rtype: :obj:`Dict[str, Optional[Tensor]]` - The output node embeddings
            for each node type.
            In case a node type does not receive any message, its output will
            be set to :obj:`None`.
        """

        H, D = self.heads, self.out_channels // self.heads

        k_dict, q_dict, v_dict, out_dict = {}, {}, {}, {}

        # Iterate over node-types:
        for node_type, x in x_dict.items():
            k_dict[node_type] = self.k_lin[node_type](x).view(-1, H, D)
            q_dict[node_type] = self.q_lin[node_type](x).view(-1, H, D)
            v_dict[node_type] = self.v_lin[node_type](x).view(-1, H, D)
            out_dict[node_type] = []

        # Iterate over edge-types:
        for edge_type, edge_index in edge_index_dict.items():
            edge_weights = edge_weight_dict[edge_type] if edge_weight_dict is not None else None
            
            src_type, _, dst_type = edge_type
            edge_type = '__'.join(edge_type)

            a_rel = self.a_rel[edge_type]
            k = (k_dict[src_type].transpose(0, 1) @ a_rel).transpose(1, 0)

            m_rel = self.m_rel[edge_type]
            v = (v_dict[src_type].transpose(0, 1) @ m_rel).transpose(1, 0)

            # propagate_type: (k: Tensor, q: Tensor, v: Tensor, rel: Tensor)
            out = self.propagate(edge_index, k=k, q=q_dict[dst_type], v=v,
                                 rel=self.p_rel[edge_type], edge_weight=edge_weights, size=None)
            out_dict[dst_type].append(out)

        # Iterate over node-types:
        for node_type, outs in out_dict.items():
            out = group(outs, self.group)

            if out is None:
                out_dict[node_type] = None
                continue

            out = self.a_lin[node_type](F.gelu(out))
            if out.size(-1) == x_dict[node_type].size(-1):
                alpha = self.skip[node_type].sigmoid()
                out = alpha * out + (1 - alpha) * x_dict[node_type]
            out_dict[node_type] = out

        return out_dict


    def message(self, k_j: Tensor, q_i: Tensor, v_j: Tensor, rel: Tensor,
                index: Tensor, ptr: Optional[Tensor], edge_weight: OptTensor,
                size_i: Optional[int]) -> Tensor:

        alpha = (q_i * k_j).sum(dim=-1) * rel
        alpha = alpha / math.sqrt(q_i.size(-1))
        alpha = softmax(alpha, index, ptr, size_i)
        out = v_j * alpha.view(-1, self.heads, 1)
        
        out = out.view(-1, self.out_channels)
        out = out if edge_weight is None else edge_weight.view(-1, 1) * out
        return out

    def __repr__(self) -> str:
        return (f'{self.__class__.__name__}(-1, {self.out_channels}, '
                f'heads={self.heads})')


class HGT(torch.nn.Module):
    def __init__(self, data, num_layers, num_hidden, num_classes, num_heads, head_node,
                dropout=0.5, lr=0.01, weight_decay=0.001, verbose=False):
        super().__init__()
        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.device = device
        self.verbose = verbose
        self.data = data.to(device)
        self.num_classes = num_classes

        self.lin_dict = torch.nn.ModuleDict()
        for node_type in data.node_types:
            self.lin_dict[node_type] = Linear(-1, num_hidden)

        self.convs = torch.nn.ModuleList()
        for i in range(num_layers - 1):
            conv = HGTConv(num_hidden, num_hidden, data.metadata(),
                           num_heads, group='sum')
            self.convs.append(conv)
        self.out_conv = HGTConv(num_hidden, num_classes, data.metadata(),
                           num_heads, group='sum')
        
        self.optimizer = torch.optim.Adam(self.parameters(), lr=lr, weight_decay=weight_decay)
        self.dropout = dropout
        self.head_node = head_node
        self.to(device)

    def forward(self, x_dict, edge_index_dict, edge_weight_dict):
        for node_type, x in x_dict.items():
            x_dict[node_type] = self.lin_dict[node_type](x).relu_()

        for conv in self.convs:
            x_dict = conv(x_dict, edge_index_dict, edge_weight)
            x_dict = {key: F.dropout(x, self.dropout, training=self.training) for key, x in x_dict.items()}

        x = self.out_conv(x_dict, edge_index_dict)[self.head_node]
        return F.log_softmax(x, dim=1)

    def fit(self, epochs=100, **kwargs):
        with torch.no_grad():  # Initialize lazy modules.
            pred = self.forward(self.data.x_dict, self.data.edge_index_dict)

        best_loss_val = np.inf
        best_acc_val = 0
        
        history = []
        for epoch in range(1, epochs + 1):
            train_mask = self.data[self.head_node].train_mask

            # Train
            self.train()
            self.optimizer.zero_grad()
            out = self.forward(self.data.x_dict, self.data.edge_index_dict)
            loss = F.cross_entropy(out[train_mask], self.data[self.head_node].y[train_mask])
            loss.backward()
            self.optimizer.step()
            
            acc = self.test()['acc']
            history.append({'val_acc': acc['val' if 'val' in acc else 'test'], 'test_acc': acc['test']})
            if self.verbose:
                print(f'Epoch: {epoch:03d}, Loss: {loss:.4f}, Train: {acc["train"]:.4f}, '
                      f'Val: {acc["val" if "val" in acc else "test"]:.4f}, Test: {acc["test"]:.4f}')

            # Validation
            if hasattr(self.data[self.head_node], 'val_mask'):
                val_mask = self.data[self.head_node].val_mask

                self.eval()
                output = self.forward(self.data.x_dict, self.data.edge_index_dict)
                loss_val = F.cross_entropy(out[val_mask], self.data[self.head_node].y[val_mask])
                acc_val = (output.argmax(dim=-1)[val_mask] == self.data[self.head_node].y[val_mask]).sum() / val_mask.sum()

                if best_loss_val > loss_val:
                    best_loss_val = loss_val
                    self.output = output
                    weights = deepcopy(self.state_dict())

                if acc_val > best_acc_val:
                    best_acc_val = acc_val
                    self.output = output
                    weights = deepcopy(self.state_dict())
        if hasattr(self.data[self.head_node], 'val_mask'):
            if self.verbose:
                print('=== picking the best model according to the performance on validation ===')
            self.load_state_dict(weights)
        return history

    @torch.no_grad()
    def test(self):        
        x_dict, edge_index_dict = self.data.x_dict, self.data.edge_index_dict
        
        self.eval()
        pred = self.forward(x_dict, edge_index_dict)
        stat = {'acc': {}, 'f1_micro': {}, 'f1_macro': {}, 'auc': {}}
        for split in ['train', 'val', 'test']:
            mask_name = f'{split}_mask'
            if hasattr(self.data[self.head_node], mask_name):
                mask = self.data[self.head_node][mask_name]
                                
                split_pred = pred.argmax(dim=-1)[mask].detach().cpu().numpy()
                split_y = self.data[self.head_node].y[mask].detach().cpu().numpy() 
                acc = accuracy_score(split_y, split_pred)
                f1_mic = f1_score(split_y, split_pred, average='micro')
                f1_mac = f1_score(split_y, split_pred, average='macro')

                auc_pred = np.exp(pred[mask].detach().cpu().numpy()) if self.num_classes > 2 else split_pred
                auc = roc_auc_score(split_y, auc_pred, multi_class='ovr')
                
                stat['acc'][split] = float(acc)
                stat['f1_micro'][split] = float(f1_mic)
                stat['f1_macro'][split] = float(f1_mac)
                stat['auc'][split] = float(auc)
        return stat